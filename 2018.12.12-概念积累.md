# 概念积累



## 宽基

所谓宽基指数指的是覆盖股票面广泛，具有相当代表性的指数基金



## 实时净值， 那么怎么简单算实时折溢价呢？

https://www.touzi.com/news/722837.html

折溢价=实时价格/预估净值

在ETF中，如果打开股票软件，你会发现一个英文缩写，IOPV。这个就是ETF的动态基金净值，比如300ETF，价格为3.205，这个是交易价格，而预估净值为3.2060。

总之一句话，价格围绕着净值上下波动，如果交易价格低于预估净值，那么低于的这部分差价就表现为折价，反之也一样。

具体可以自己算，比如一只ETF的净值为1元，交易价格为0.8元，那么折价就是0.2元，折价率为0.2/1=20%。当然一般折溢价不会这么高，基本上都在5%左右。

对于ETF的折溢价很好算，难的就是LOF基金了，LOF基金没有IOPV这个东东，只好自己算预估净值了，LOF指数基金的预估净值=T-1基金净值*（T日涨跌幅*95%+1）。

因此碰到场内基金折溢价的时候，大家都是场外申购，然后在场内卖出，这样就可以套利，以后有具体事例，给大家再示范一下。目前场内基金经常寻找折溢价的基金有华宝油气、医药ETF、南方原油。

## 股票仓位和基金仓位不同

很多用户都会把基金仓位和股票仓位搞混。股票仓位大家都知道是指你投资该股占到你所有资金的比例。而基金仓位并非很多人以为的一只基金占到你基金账户中资金的比例。

**基金仓位是什么意思**

基金仓位通俗的讲就是基金资产中股票资产占全部资产的比重,比如某只基金总资产为10个亿,其中股票资产有8个亿,其他资产(债券、现金等)为2个亿,那么我们就说该基金的仓位为80%。

**基金仓位与上证指数的关系**

由于股票型基金、混合型基金都投资有一定比例的股市资产，再加上基金体量较为庞大，因此基金仓位的提高或降低，都会直接影响到指数的高低。同时,当基金仓位很高时,比如股基的平均仓位达到88%以上时,基金可加仓空间有限,此时,基金买盘动能减弱,股指往往会下跌。

**基金仓位测算方法**

基金中报里所告知的仓位数据滞后性严重，参考价值并不大，而且仓位在其他时间并不会公布，属于公司的商业机密。但是仍然有很多第三方研究机构通过数学模型的计算来得出基金仓位水平的大致数值。而作为我们个人又该如何计算呢？

**股票市值与净值的比**

以前大家都喜欢拿基金每个季度公布的股票市值与净值的比来计算基金仓位水平。但是使用这种算法存在一个问题，那就是市值与净值都包含有估值增值的部分，因此这些数字不能代表基金的实际投入，无法准确表示基金的仓位。

**股票成本与扣除估值增值后的净值之比**

这种算法实际上就是用股票成本与股票成本及可用流动资金之比所计算出的仓位，其包含的真实意思有：基金短期内可动用的资金也包括在内(银行存款加各项应收款与应付款之差)，反映的是基金可支配的总体资金状况。这应该是较为准确全面的仓位计算方法。

**股票成本与股票债券成本及银行存款之比**

这种算法实际上是侠义概念上的仓位，在计算过程中将基金未投入股市的资金默认为其银行存款，而没有计算应收应付净额。


## 怎么理解基金仓位大于100%？

[计算方式](https://wenku.baidu.com/view/7cb429ef0975f46527d3e120.html)

**基金仓位的计算**

基金仓位等数据是基金公司的机密，只能在发布年报等定期报告时才能一睹芳容。

08年6月10日出现大盘暴跌8%、超过1000只个股跌停的罕见场景，基金净值全面遭受重创，特别是股票型基金，单日净值跌幅基本在5%以上，其中有24只基金的净值跌幅超过7%。由于周二基金重仓股全线暴跌，而且除了极个别股票外，基本所有重仓股跌幅都一致，个股表现差异对基金净值的影响很小，所以基金净值表现差异主要是股票仓位不同导致的，由此基金的股票仓位情况被破解了。

**计算基金仓位的方法很简单，就是利用6月10日当天的基金净值变化率，除以市场的整体跌幅，我们选择的是代表性极强的沪深300指数，当天下跌8.11%，仓位=净值变动率÷沪深300指数变动率100%。比如嘉实沪深300指数型基金6月10日净值下跌7.76%，该基金的仓位计算公式就是(-7.76%/-8.11%)100%，计算结果显示目前嘉实沪深300指数型基金的仓位为95.68%，与指数型基金的配置水平吻合。**



实际100%以上的仓位是不可能，实际情况只是本基金的持股表现跑赢了对应的指数而已。

对于JSL，仓位应该只是估算出来的，并不是拿的基金公司的数据，仓位计算是根据指数的涨幅，与基金实际净值的涨幅的比例关系计算。理论上100%仓位，基金净值涨幅度应该与指数相同，低于100%，涨跌幅应该比指数小。但实际误差总是存在，有时候可能还不小，若净值涨跌的如果比指数还猛，JSL就只好给它定个100%以上的仓位了。  



仔细想想可能四种情况：

第一种情况，如果指数涨跌幅在0.5%以内出现仓位超过100%甚至200%我觉得都有可能，毕竟指数涨跌幅度很小，只要误差稍大造成摊下来的仓位误差就很大

第二种情况，基金赎回和基金申购被动造成指数涨跌幅波动很大，假如说基金经理预估今天折价套利赎回可能15%的仓位，基金经理只是做了减仓10%左右仓位应对赎回，但是今天晚上发现赎回高达30%，因此明天被动减仓20%左右应对赎回，这样如果明天的指数大涨或者大跌，造成基金净值会出现和指数净值较大误差的情况，造成仓位虚高或者极低

第三种情况，就是大量的基金赎回或者申购得到的申购费或者赎回费算做基金收益造成涨跌幅和指数涨跌幅的误差，测算出来仓位的误差很大

第四种情况，就是跟踪指数误差，本来指数基金可能几百只股票，但是母基金由于资金有限，只能代表性选择股票建仓造成跟踪误差，反映出来就是仓位的误差情况

以上不知道理解的对不对，欢迎各位补充

## 股票仓位计算

对于普通账户非信用账户，总资产就是可用资金 + 非股票资产（国债逆回购，货币基金等等）+ 股票市值（会随着盈亏变动的） ，不转入资金的情况下，如果持仓股票下跌，你的持仓市值也会缩水，仓位会被动降低，股票上涨，持仓市值增加，仓位也会被动增加。

仓位是指投资人实际投资和实有投资资金的比例。

计算公式为：实际投资资金 ÷ 实有投资资金=仓位

### ## 仓位

仓位是指投资人实有投资和实际投资资金的比例。列举个例子：比如你有10万用于投资，现用了4万元买基金或股票，你的仓位是40%。如你全买了基金或股票，你就[满仓](https://baike.baidu.com/item/%E6%BB%A1%E4%BB%93)了。如你全部赎回基金卖出股票，你就[空仓](https://baike.baidu.com/item/%E7%A9%BA%E4%BB%93/3070255)了

### 术语

基金持仓，即你手上持有的基金份额。

另外的基金术语，可以参考：

建仓：对于基金公司来说就是指一只新基金公告发行后，在认购结束的封闭期间，基金公司用该基金第一次购买股票或者投资债券等（具体的投资要示该基金的类型及定位来确定）。对于私人投资者，比如说我们自己，建仓就是指第一次买基金。

加仓：是指建仓时买入的基金净值涨了，继续加码申购。

补仓：指原有的基金净值下跌，基金被套一定的数额，这时于低位追补买进该基金以摊平成本。（被套—简单的说就是投资人以某净值买的基金跌到了该净值以下。比如1.2元买的跌到了0.98元，那就是说投资人在该基金上被套0.22元）

满仓：就是把你所有的资金都买了基金，就像仓库满了一样。大额资金投入的叫大户，更大的叫庄家；小额资金投入的叫散户，更小的叫小小散户。

半仓：即用一半的资金买入基金，帐户上还留有一半的现金。如果是用70%的资金叫7成仓…可依此类推。如你有2万资金1万买了基金，就是半仓，称半仓操作。表示没有把资金全部投入，是降低风险的一个措施。

重仓：重仓是指这只基金买某种股票，投入的资金占总资金的比例最大，这种股票就是这只基金的重仓股。同理如果你买了三只基金，有70％的资金都投资在其中一只上，那么这只基金就是你的重仓。

轻仓：反之即轻仓

# Oracle与PL/SQL是什么关系

ORACLE是数据库，有客户端和服务器； PLSQL Developer只是第三方工具，服务于ORACLE，类似的工具还有Toad，sqlplus，sql developer等等； 安装PLSQL Developer于安装oracle没啥关系，但是如果没有oracle客户端，你装了PLSQL Developer也没啥意 
SQL*Plus 是Oracle自带的数据库管理客户端，可以在这里编辑SQL语句执行，是命令行模式的。 
PL/SQL 有两种。 一种是工具 PL/SQL Developer 和SQL*Plus一样是数据库管理客户端，是一种可视化界面，也可以使用命令行编辑SQL。 
另外一种是PL/SQL语言，是oracle中的块结构语言，类似存储过程，是一种过程话的语言。把SQL语言和编程高级语言想融合，和Java近似。既可以在SQL*Plus上开发PL/SQL语言，也可以在PL/SQL Developer上开发PL/SQL语言。 

9l和之前是整合客户端和服务端的，10G和以后是分离的，服务端是数据库所在的位置，客户端只是一个提供连接服务端和开发相关的工具，sql通过客户端发送到服务端解析执行，每次都解析很麻烦，所以干脆把一些使用频繁的sql扔在服务端，就出来了可编程式函数：存储过程，存储函数，触发器什么的，plsql是独立的语言，只是为了更好的实现可编程式这个概念。