# C++引用

### c++ 为什么要引入引用?

c++ 在某些程度来说，是c的一个扩充和改善，我们知道，c程序一个非常显著的优势就是c程序的执行效率，而c高效执行的原因就是对指针的操作（直接对内存进行操作）.绝大部分c程序员来说，对指针是又爱又恨，爱它，是因为 ，c语言指针所带来的效率是其它程序无法比拟的，但对指针操作不慎带来的bug。而c++ 语言设计之初，**c++委员会，即想保持c指针的高效，又不想有指针的缺点，所以就引入了引用这一概念**，但是后来，却发现，指针没法被引用取代。

**引用（reference）： 引用只是别名，不是实体类型（也就是说c++编译器不为引用单独分配内存空间），对一个对象的引用，就是直接对这个对象的操作。**

###特点

我们可以把**引用**理解成**变量**的**别名**。定义一个引用的时候，程序把该**引用和它的初始值绑定在一起，而不是拷贝它**。计算机必须**在声明r的同时就要对它初始化**，并且，**r一经声明，就不可以再和其它对象绑定在一起了。**

实际上，你也可**以把引用看做是通过一个常量指针来实现的，它只能绑定到初始化它的对象上**。

关于指针和引用的对比，可以参看<<more effective C++>>中的第一条条款，**引用的一个优点是它一定不为空**，因此相对于指针，它不用检查它所指对象是否为空，这增加了效率。

````c++
#include <iostream>
using namespace std;

typedef struct {
    int x;
    int y;
}Coord;

void fun(int &a, int &b);

int main() {

    //int &n = NULL;是错误的，引用不允许为NULL
    //int &n;是错误的，引用不允许单独存在


    //对变量
    int m = 10;
    int &n = m;
    n = 20;
    cout << m << endl;
    m = 30;
    cout << n << endl;


    //对变量
    int x = 3;
    //定义引用，y是x的引用
    int &y = x;
    //打印x和y的值
    cout << x << endl;
    cout << y << endl;
    //修改y的值
    y = 10;
    //再次打印x和y的值
    cout << x << endl;
    cout << y << endl;


    // 对结构体
    Coord c;
    Coord &c1 = c;
    Coord &c2 = c1;

    c1.x = 10;
    c2.y = 20;

    cout << c.x << " " << c.y << endl;

    // 对指针
    int a = 3;
    int *p = &a;
    int *&q = p;
    cout << a << endl;
    *q = 5;
    cout << a << endl;

    // 对函数利用引用，可以不采用地址、指针等

    int i = 100;
    int j = 200;
    cout << i << " " << j << endl;
    fun(i, j);
    cout << i << " " << j << endl;

    return 0;
}

void fun(int &a, int &b){
    int c;
    c = a;
    a = b;
    b = c;
}
````



# C++中的引用和指针的区别

### 指针和引用的定义和性质区别：

(1)指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：

```
int a=1;int *p=&a;
int a=1;int &b=a;
```

上面定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。
而下面2句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。

(2)可以有const指针，但是没有const引用；

(3)指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）

(4)指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；

(5)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。

(6)"sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小；

(7)指针和引用的自增(++)运算意义不一样；

### 指针和引用作为函数参数进行传递时的区别

用指针传递参数，可以实现对实参进行改变的目的，是因为传递过来的是实参的地址，因此使用*a实际上是取存储实参的内存单元里的数据，即是对实参进行改变，因此可以达到目的。

引用作为函数参数进行传递时，实质上传递的是实参本身，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。



# 函数默认值

有默认参数值的参数必须在参数表的最右端。

无实参则使用默认值，否则实参覆盖默认值。比如：fun(20), fun(20, 30), fun(20, 30, 40)

# 函数重载

###编译器如何识别重载的函数？

getMax(int x, int y, int z)            -------> getMax_int_int_int

getMax(double x, double y)      ------->  getMax_double_double

# 内联函数

### 普通函数：比如main中调用fun()，每次运动到fun()时，就直接去fun定义处进行调用

写成函数有一个**潜在的缺点**：调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行

### 内联函数：编译时，将函数体代码和实参代替函数调用语句

好处：减少了去调用fun()的时间

目的是为了**提高函数的执行效率**，用**关键字 inline 放在函数定义(注意是定义而非声明**，下文继续讲到)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开，假设我们将 max 定义为内联函数：

```
inline int max(int a, int b)
{
    return a > b ? a : b;
}1234
```

则调用：`cout << max(a, b) << endl;`

在编译时展开为：`cout << (a > b ? a : b) << endl;` 从而消除了把 max写成函数的额外执行开销。

内联函数关键字**inline**

### 内联函数和宏

![内联函数和宏](https://raw.githubusercontent.com/zhangjinzhi/Summary/master/define_inline.jpeg)



### 将内联函数放入头文件

关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。

如下风格的函数 Foo 不能成为内联函数：

```
inline void Foo(int x, int y);   // inline 仅与函数声明放在一起   
void Foo(int x, int y)
{
    //...
} 12345
```

而如下风格的函数 Foo 则成为内联函数：

```
void Foo(int x, int y);   
inline void Foo(int x, int y)   // inline 与函数定义体放在一起
{
    //...
} 12345
```

所以说，C++ **inline函数是一种“用于实现的关键字”，而不是一种“用于声明的关键字”**。一般地，用户可以阅读函数的声明，但是看不到函数的定义。**尽管在大多数教科书中内联函数的声明、定义体前面都加了 inline 关键字，**但**inline 不应该出现在函数的声明中。**这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：**声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。**

定义在类声明之中的成员函数将自动地成为内联函数，例如：

```
class A
{  
public:
    void Foo(int x, int y) { ... }   // 自动地成为内联函数  
} 12345
```

但是编译器是否将它真正内联则要看 Foo函数如何定义

内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 inline 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。

当然内联函数定义也可以放在源文件中，但此时只有定义的那个源文件可以用它，而且必须为每个源文件拷贝一份定义(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。

找不到函数的定义，**所以内联函数可以在程序中定义不止一次，只要 inline 函数的定义在某个源文件中只出现一次，而且在所有源文件中，其定义必须是完全相同的就可以。**

在头文件中加入或修改 inline 函数时，使用了该头文件的所有源文件都必须重新编译



### 慎用内联

**递归函数无法使用内联方式**

![内联的不足](https://raw.githubusercontent.com/zhangjinzhi/Summary/master/drawbackOfInline.jpeg)

而在Google C++编码规范中则规定得更加明确和详细：

> #### 内联函数：
>
> #### Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.
>
> 定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用. 
> 优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联. 
> 缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。 
> 结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用! 
> 另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行). 
> 有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.
>
> -inl.h文件：
>
> #### Tip： 复杂的内联函数的定义, 应放在后缀名为 -inl.h 的头文件中.
>
> 内联函数的定义必须放在头文件中, 编译器才能在调用点内联展开定义. 然而, 实现代码理论上应该放在 .cc 文件中, 我们不希望 .h 文件中有太多实现代码, 除非在可读性和性能上有明显优势.
>
> 如果内联函数的定义比较短小, 逻辑比较简单, 实现代码放在 .h 文件里没有任何问题. 比如, 存取函数的实现理所当然都应该放在类定义内. 出于编写者和调用者的方便, 较复杂的内联函数也可以放到 .h 文件中, 如果你觉得这样会使头文件显得笨重, 也可以把它萃取到单独的 -inl.h 中. 这样把实现和类定义分离开来, 当需要时包含对应的 -inl.h 即可。













