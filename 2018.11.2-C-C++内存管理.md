# C/C++内存管理——申请/归还内存资源

## 内存管理方式

### [malloc/free和new/delete区别](http://www.cnblogs.com/QG-whz/p/5140930.html)

`malloc`与`free`是C++/C语言的标准库函数，`new/delete`是C++的运算符。它们都可用于申请动态内存和释放内存。
　　对于非内部数据类型的对象而言，光用`maloc/free`无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于`malloc/free`是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于`malloc/free`。
　　因此C++语言需要一个能完成动态内存分配和初始化工作的运算符`new`，以及一个能完成清理与释放内存工作的运算符`delete`。注意`new/delete`不是库函数。

| 特征                 | new/delete                            | malloc/free                          |
| -------------------- | ------------------------------------- | ------------------------------------ |
| 分配内存的位置       | 自由存储区                            | 堆                                   |
| 内存分配成功的返回值 | 完整类型指针                          | void*                                |
| 内存分配失败的返回值 | 默认抛出异常                          | 返回NULL                             |
| 分配内存的大小       | 由编译器根据类型计算得出              | 必须显式指定字节数                   |
| 处理数组             | 有处理数组的new版本new[]              | 需要用户计算数组的大小后进行内存分配 |
| 已分配内存的扩充     | 无法直观地处理                        | 使用realloc简单完成                  |
| 是否相互调用         | 可以，看具体的operator new/delete实现 | 不可调用new                          |
| 分配内存时内存不足   | 客户能够指定处理函数或重新制定分配器  | 无法通过用户代码进行处理             |
| 函数重载             | 允许                                  | 不允许                               |
| 构造函数与析构函数   | 调用                                  | 不调用                               |

malloc给你的就好像一块原始的土地，你要种什么需要自己在土地上来播种.

而new帮你划好了田地的分块（数组），帮你播了种（构造函数），还提供其他的设施给你使用.

**malloc并不是说比不上new，它们各自有适用的地方。在C++这种偏重OOP的语言，使用new/delete自然是更合适的。**

### C的用法

```c++
void *malloc(size_t size);
void free(void *memblock);
```

### C++的用法

```c++
new
delete

int *p = new int[10];
delete []p;

int *p = new int;
delete p;
```

****

###注意事项：

#### 使用方式：配套使用，不能混搭

#### 申请内存时：要判断

有可能失败，所以要判断

```c++
int *p = new int[1000]；
if( p == NULL){
    //内存分配失败
    //异常处理
}
```

####释放内存时：有两步

```c++
int *p = new int[1000]；
if( p == NULL){
    //内存分配失败
    //异常处理
}

//第一步释放内存
delete []p; //释放内存后，p指针依然指向该内存
//将指向内存的p指针置为NULL
p = NULL; //所以将指针置为空
```

**free或delete后,没有将指针设为NULL,产生”野指针”。**

### 这种管理内存的方式有什么缺点呢？

因为我们申请的内存块 大小 不定，申请和释放时间也不相同。 所以 这个堆 （连续的整个内存块） 会形成 零零散散的情况（称为内存碎片）。 并且 查询这两张表 需要时间，所以如果申请和释放堆内存比较频繁的话，会比较浪费时间。 
总之，缺点就是 时间和空间消耗严重。

###这种管理方式的优点呢？

通用。 
因为你可以申请任意大小的内存。

## [内存池](http://cplusplus.wikidot.com/cn:memory-management) 

###什么是内存池？

综上所述： 内存池就是 预先分配好的 一块大内存。 通过程序员自身 对 这块大内存的管理，来满足自身特殊的 内存 申请和释放的需求。 （比如，申请的内存块总是 256B 这个大小）

###内存池的优点是什么：

可以极大的加快内存 申请 和释放的过程。达到 O(1) 级别。 
可以在一定程度上减少内存锁片的产生。

###内存池的缺点是什么：

不够通用, 只能分配特定长度的字节，不是通用的内存管理器。 

内存池可能导致内存占用只增加，不减少。



##堆、栈、自由存储区、全局/静态存储区和常量存储区

在C++中内存分为5个区，分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。

**堆**: 堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，**C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。**

**栈**: 在执行函数时，**函数内局部变量**的存储单元都可以在栈上创建，函数执行结束时这些存储单元**自动被释放**。栈内存分配运算内置于处理器的指令集中，**效率很高**，但是**分配的内存容量有限**。

**自由存储区:** 自由存储区是C++基于new操作符的一个抽象概念，**凡是通过new操作符进行内存申请，该内存即为自由存储区。**

**全局/静态存储区:** 这块内存是在**程序编译的时候就已经分配好的**，在程序整个运行期间都存在。例如全局变量，静态变量。

**常量存储区:** 这是一块比较**特殊的存储区**，他们里面存放的是常量(const)，**不允许修改**。



##常见的内存错误及解决方法

　　a.内存分配未成功，却使用了它。

　解决方法：在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。如果是用new来申请内存，申请失败是会抛出异常，所以应该捕捉异常来进行放错处理。(感谢[@](https://link.jianshu.com?t=http://www.cnblogs.com/QG-whz/)melonstreet指出)。

　　b.内存分配虽然成功，但是尚未初始化就引用它。

解决方法：尽管有时候缺省时会自动初始化，但是无论创建什么对象均要对其进行初始化，即便是赋零值也不可省略，不要嫌麻烦。

　　c.内存分配成功，但越界访问。

　解决方法：对数组for循环时要把握边界，否则可能会导致数组越界。

　　d.忘记了释放内存，导致内存泄漏。

　解决方法：动态内存的申请和释放必须配对，new-delete和malloc-free且使用次数必须相同。　　c.已经释放内存却仍然使用它。

　有三种情况：

1.程序中对象的关系过于复杂,难以搞清哪个对象是否已经释放了内存。

2.函数中return写错,返回了指向栈中的指针或引用。

3.free或delete后,没有将指针设为NULL,产生”野指针”。





























