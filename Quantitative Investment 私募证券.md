# 量化实现

数学计算、算法、概率统计等
有Linux基础，算法，逻辑，概率和组合
c/c++的一些基本知识，还有就是数学知识，比如概率论，一些算法比如递归。
编程和SQL

**2018年8月**

1. C++基础 
（1）template之类
（2）一个任意类型的数，移动5个比特位，怎么做

2.vector中2000个数，删了一个，如何找到

3. 25匹马比赛，最少的次数判断出前几名，一共需要比几次

选做： 11位数乘以8位数，19320814135736乘以1382345678是多少

4. 1到1000数中，马云随意选一个数k，你选择一个数m。
  （1）若m>k，则扣你一块，若m<k，则扣你一块。你需要至少多少钱，能保证一定能猜中这个数
  （2）若m>k，则扣你一块，若m<k，则扣你两块。你需要至少多少钱，能保证一定猜中这个数
  （3）若m>k，则扣你1.5元，若m<k，则扣你一块。你需要至少多少钱，能保证一定猜中这个数

5. 
（1）有五个红球，八个白球。然后你先从中随便摸一个球，然后扔了，然后再摸一个球，如果跟之前的颜色是一样的则扔回去。再重复第一步，如果跟之前的球不一样了，把这个球扔了。
（2）最小步数。一个数n，要让n变成1，你每次可以选三个操作，如果n能被三整除就除以三，如果n能被二整除就除以二，或者加一或者减一。只能选择这四个操作中的三个操作。

6. 你要把三万袋粮食从一个地方运到另外一个地方，两个地方相隔一百公里。然后你每次最多只能运一万担，但然后每天你会消耗两千五百担。
   然后呢，每天你只能走二十五公里。但是你可以在朝路上随意建立粮仓储存。最多能大概运多少袋粮食运到另外一个地方。



**2018年10月**

1. SQL
数据表如下：

| 姓名 | 课程 | 分数 |
| ------ | ------ | ------ |
| 张三 | 语文 | 79 |
| 李四 | 数学 | 70 |
| 李四 | 英文 | 89 |
| 王五 | 语文 | 99 |
| 王五 | 英文 | 70 |
| ... | ... | ... |


（1）写SQL语句，选出所有课程都大于80分的学生的姓名
（用一条SQL 语句，查询出每门课都大于80分的学生姓名）

select distinct 姓名 from table where 姓名 not in (select distinct 姓名 from table where 分数<=80);

select 姓名 from table group by 姓名 having min(分数)>80;

select 姓名 from table group by 姓名 having min(分数)>80 and count(课程)>3;

select 姓名 from table group by 姓名 having count(分数)=sum(case when score>80 then 1 else 0 end);


| 自动编号 | 学号 | 姓名 | 课程 | 分数 |
| ------ | ------ | ------ | ------ | ------ |
| 1 | 2005001 | 张三 | 语文 | 79 |
| 2 | 2005002 | 李四 | 数学 | 70 |
| 3 | 2005002 | 李四 | 英文 | 89 |
| 4 | 2005003 | 王五 | 语文 | 99 |
| 5 | 2005003 | 王五 | 英文 | 70 |

（2）删除除了自动编号不同, 其他都相同的学生冗余信息

delete table where 自动编号 not in (select 自动编号 from table group by 学号,姓名,课程,分数);


2. [1, 2, 5, 10, 20, 50, 100]，从数组中取若干个数字，使得和为100，请问一共有多少种取法？

根据代码运行结果得到：

1、2、5相加100的组合数是: 541

1、2、5、10、20、50、100相加100的组合数是: 4563

1、2、5、10、20、50相加100的组合数是: 4562

3. 编程：给定一个数字n，得到[1,n]区间内所有满足a^b = c^b的等式数量，(1^2=1^1和 1^1=1^2算为两个式子)

4. M个乘客登机，飞机上有N个座位，N>=M。为了避免拥挤，规定，前一个乘客坐到座位上后，下一个乘客才可以入座。
但是第一名乘客的飞机票的座位号被污染，看不清楚座位号，所以第一名乘客会随便选一个座位入座。如果后续登机的乘客指出第一名乘客坐到了自己的位子，则第一名会离开座位，重新随便选一个座位坐下。如果没有被后续乘客指出坐错座位，则保持不动。
（1）N=M时，计算出第一名乘客移动座位的次数的期望。（如果第一名乘客第一次就坐对了自己的座位，则移动次数为0）
（2）N>M时，编程采用随机模拟算法，计算出第一名乘客移动座位的次数的期望

5.(1) 编程实现axa方阵的转置。不借助额外连续内存空间，采用一切可行的优化技巧。
  (2) 编程实现axb矩阵的转置。

6.编程实现最小步数。一个数n，要让n变成1，你每次可以选三个操作，如果n能被三整除就除以三，如果n能被二整除就除以二，或者加一或者减一。
  只能选择这四个操作中的三个操作。














## 针对上面的题目2. [1, 2, 5, 10, 20, 50, 100]，从数组中取若干个数字，使得和为100，请问一共有多少种取法？多种解法、变形题


------



### 题目1、给定一个值,如100，给定一个数组，从数组中挑选出N个元素，这N个元素相加也是100，得到一种结果就行

如数组：

```
var arr = [99.1, 92.2, 60, 50,
           49.5, 45.7, 25.1, 20, 
           17.4, 13, 10, 7, 2.1, 2, 1];
```

找到和为100的数组元素：

```
[60,20,10,7,2,1]
```



**Python 版的解答:**

```python
def subsetsum(elements, target):
    if target==0:
        return True, []
    elif not elements or target < 0:
        return False, None

    result, subset = subsetsum(elements[:-1], target-elements[-1])
    return (True, subset + [elements[-1]]) if result else subsetsum(elements[:-1], target)
```

### 题目2、写一个程序, 要求功能：求出用1，2，5这三个数不同个数组合的和为100的组合个数。如：100个1是一个组合，5个1加19个5是一个组合。。。。 请用C++语言写。

最容易想到的算法是：

设x是1的个数，y是2的个数，z是5的个数，number是组合数

注意到0<=x<=100，0<=y<=50，0<=z=20，所以可以编程为：

```c++
number=0;
for (x=0; x<=100; x++)
	for (y=0; y<=50; y++)
		for (z=0; z<=20; z++)
			if ((x+2y+5z)==100)
				number++;

cout<<number<<endl;

```

事实上，这个题目是一道明显的数学问题，而不是单纯的编程问题。

因为x+2y+5z=100

所以x+2y=100-5z，且z<=20 x<=100 y<=50

所以(x+2y)<=100，且(x+5z)是偶数

对z作循环，求x的可能值如下：

z=0, x=100, 98, 96, … 0

z=1, x=95, 93, …, 1

z=2, x=90, 88, …, 0

z=3, x=85, 83, …, 1

z=4, x=80, 78, …, 0

……

z=19, x=5, 3, 1

z=20, x=0

 

因此，组合总数为100以内的偶数+95以内的奇数+90以内的偶数+…+5以内的奇数+1，

即为： (51+48)+(46+43)+(41+38)+(36+33)+(31+28)+(26+23)+(21+18)+(16+13)+(11+8)+(6+3)+1

某个偶数m以内的偶数个数（包括0）可以表示为m/2+1=(m+2)/2

某个奇数m以内的奇数个数也可以表示为(m+2)/2

所以，求总的组合次数可以编程为：

```c++
number=0;
for (int m=0;m<=100;m+=5)
{
	number+=(m+2)/2;
}
cout<<number<<endl;

```



### 题目3、[1, 2, 5, 10, 20, 50, 100]，从数组中取若干个数字，使得和为100，请问一共有多少种取法？

#### 解法一：

多重循环，不是实用，**但是可以用来检验优化算法的正确性**。

**这也是测试的一种思路，针对优化后的算法，可以用最简单、最笨、但最容易确定其正确性的算法去检验**

````c++
int Utils::Sum_Combination_1_2_5_10_20_50_100(int nSum)
{
    int nCnt = 0;
    int x, y, z;
    for (x = 0; x <= (nSum/1); x++){
        for (y = 0; y <= (nSum/2); y++){
            for (z = 0; z <= (nSum/5); z++){
                for (int a = 0; a <= (nSum/10); ++a) {
                    for (int b = 0; b <= (nSum/20); ++b) {
                        for (int c = 0; c <= (nSum/50); ++c) {
                            for (int d = 0; d <= (nSum/100); ++d) {
                                if ((x + 2*y + 5*z + 10*a + 20*b + 50*c + 100*d) == nSum)
                       }
                   }
               }
           }
       }
    }
   return nCnt;
}
````

#### 解法二：

考虑递推公式：

最初想法：是借鉴青蛙跳台阶的思路

f(n) = f(n - 1) +  f(n - 2) +  f(n - 5) +  f(n - 10) +  f(n - 20) +  f(n - 50) +  f(n - 100)

通过变换去接触通式，但是无法很方便地接触

#### 解法三：

找到递推公式之后，其实也不难

F(N,M)=F(N,M-1)+F(N-VAL[M],M)

F(N,M)表示 用不超过第M个值的数来表示N 的所有组合方案
举个栗子
我们先看4的组成
4 = 2+2 = 2+1+1 = 1+1+1+1共3种方案
我们再看公式，例如
F(4,6) = F(4,5) + F(4-VAL[6],6) 
= F(4,5) + F(4-50,6)
= F(4,5) + F(-46,6)
= F(4,5)

F(4,5) = F(4,4) + F(4-VAL[5],5) 
= F(4,4) + F(4-20,5)
= F(4,4) + F(-16,5)
= F(4,4)

F(4,4) = F(4,3) + F(4-VAL[4],4) 
= F(4,3) + F(4-10,4)
= F(4,3) + F(-6,4)
= F(4,3)

F(4,3) = F(4,2) + F(4-VAL[3],3) 
= F(4,2) + F(4-5,3)
= F(4,2) + F(-1,3)
= F(4,2)

F(4,2)  = F(4,1) + F(4-VAL[2],2) 
    = F(4,1) + F(4-2,3)
= F(4,1) + F(2,3)
= F(4,1) + F(2,3)

F(4,6) 的所有组合方案其实就是F(4,2)的组合方案，毕竟VAL[3]~VAL[6]均大于4，不可能存在更多的组合方案，
所以，
用不超过第6个值的数（即50元）来表示4元 的所有组合方案【F(4,6)】
等于  用不超过第2个值的数（即2元）来表示4元 的所有组合方案【F(4,2)】
那么，
用不超过第2个值的数（即2元）来表示4元 的所有组合方案【F(4,2)】
又等于
用不超过第1个值的数（即1元）来表示4元 的所有组合方案 
加上 
用不超过第3个值的数（即5元）来表示2元 的所有组合方案【F(4,1)+F(2,3)】
明显F(4,1)所代表的方案就是4=1+1+1+1，即F(4,1)=1
而F(2,3)也可以用上述推导的方式，即F(2,3)=F(2,2)=F(2,1)+F(0,2)=....=F(2,1)+F(0,0)=2
F(0,0)可以理解成用0元来表示0元，这算是1种方案

此时我们就能看出4的组合方案，其实就是
4=2+2
4=2+1+1
【F(4-VAL[2],2)，意味着把红色数字减去 ，即F(2,2)代表上面两种方案】
4=1+1+1+1

【F(4,1)代表4=1+1+1+1方案】

```c++
int Utils::Best_Solution_1_2_5_10_20_50(int nSum) {
    int val[7] = { 0,1,2,5,10,20,50 };
    int f[101][7];
    memset(f, 0, sizeof(f));

    for (int j = 0; j <= 6; j++)
        f[0][j] = 1;

    for (int j = 1; j <= 6; j++)
    {
        for (int i = 1; i <= 100; i++)
        {
            if (i - val[j] < 0)
                f[i][j] = f[i][j - 1];
            else
                f[i][j] = f[i - val[j]][j] + f[i][j - 1];
        }
    }

    //cout << test(0, 100) << endl;
    //cout << ans << endl;
    return f[100][6];
}
```



