# Java变量和对象的作用域

大多数程序设计语言都提供了“作用域”（Scope）的概念。

对于在作用域里定义的名字，作用域同时决定了它的“可见性”以及“存在时间”。在C，C++和Java里，作用域是由花括号的位置决定的。

# Java与C++在作用域上的区别

Java语言与C++语言是目前最流行的编程语言。两者的编程思想虽然有一定的共同性，但是在很多方面仍然存在着比较大的差异。如两者在作用域上仍然存在着很大的差异

　　**差异一：变量作用域的不同。**

　　如下图，这段程序代码是符合C++语言的语法要求的。其可以在C语言下正常运行。但是其在Java语言平台下编译的时候，就会被告知有错误。其格式、关键字上面都没有错误。那么错误到底是这么呢?这就关系到变量的作用域。

```
　  { 
　　float y=3.14
　　{ 
　　float y=3.15 
　　} 
　　}
```

　　作用域就决定了其定义的变量名的可见性与生命周期。在C++语言(包括其衍生出来的其他语言)与Java语言中，都是用一定花括号来代表一个作用域的。如上面的代码，就表示有两个作用域。外面一对花括号代表一级作用域;里面一对花括号代表二级作用域，依次类推。通常情况下，一级作用域中定义的变量，对其下级作用率都是有效的。也就是说，其下级作用域可以直接引用上级作用域中定义的变量。但是在二级作用域中，可以更改一级作用率中设置的变量值，不过这个更改只在二级作用域内部有效。如上面这个代码，在二级作用域中可以再定义一个y变量，重新赋值。注意，其实在二级作用域中定义的变量与一级作用域中定义的变量，虽然名字相同，但是他们不是同一个变量。如果此时在一级作用域外，有其他代码引用这个y变量的话，则其的值仍然是3.14，而不会是3.15。也就是说，在二级作用域中定义的变量，只在其内部有效。对于上级作用域是没有丝毫影响的。也就是说，在作用域中定义的变量只在其作用域内有效。出了其作用域外，其内部设置的变量就全部无效了。

　　这个作用域的设置其实Java语言与C++语言是类似的。但是**在细节上Java语言又多了一条限制**。如上表的代码所示，虽然在上面的代码中变量y在两个不同的作用域中定义，照理来说是两者是互不干涉，可以共存。**但是在Java编译器中，是不允许有这种情况存在的**。把上面这个代码在Java编译器中编译的话，编译器会通知程序开发人员，说这个变量y已经定义过。然后编译会以错误告终。**虽然在C++语言中在不同级别的作用域中定义名字相同的变量是允许的，而在Java语言中则不行**，这并不代表在变量的作用域上有所不同。其实从本质上来说，两者变量的作用域是相同的。只是对于Java语言来说，其又多加了一条限制。**在Java语言中，即使作用域不同，其定义的变量名字也不能够相同。这主要是为了提高Java代码的可读性，防止混淆才定义了这条规则。**

　　**差异二：对象作用域的差异。**

　　Java语言与C++语言一样，都是面向对象的语言。不过两者在实现机制上有很大的不同。就拿对象的作用域来说，就有很大的差异。这也导致了两个面向对象的语言在实现细节上的巨大差异。

　　首先Java程序员需要明白的是，Java对象作用域与变量的作用域是不同的。如上面的分析，变量的作用域只在作用域内部有效。如在二级作用域内定义的变量，超出了二级作用域，那么就无效了。但是对象则不同，其可以存在于作用域之外。如现在在某个作用域内定义了一个name_full对象。当脱离这个作用域的时候，这个对象的引用是消失了。但是刚才创建的这个对象仍然实实在在的保存在内存中。在Java程序的运行过程中，只要通过传递或者复制对象引用的手段，那么在其他作用域内仍然可以访问这个对象。也就是说，只要我们有这个需要，那么在某个作用域内创建的对象其会一直存在并可以在作用域外的其他任何一个地方进行访问。当然前提是要通过复制或者传递等手段把对象引用传递到其他的作用域中。这就是Java对象与Java变量在作用域上最大的不同。

其次，Java对象与C++语言的作用域有很大的不同。**其实C++语言中的对象跟变量的作用域到是很类似的。在C++语言中一旦使用完对象之后，就必须把这个对象销毁掉**。说的确切一点，就是要在**作用域内把使用完的对象所占的内存空间释放掉。**否则的话，如果在作用于外部，由于已经失去了对这个对象的引用，为此这个对象就好像成为了太空中的一个人，无法再对其进行任何的操作，只要任其自生自灭。为此对于C++语言来说，程序员很难在脱离作用域外后，确保在需要调用对象时，仍然可以访问这个对象。这也正是C++语言开发过程中最让人头疼的问题。因为需要手工来销毁对象。万一对象所占用的内存空间没有别及时释放的话，那么对于应用程序的安全与性能都会产生很大的影响。

　　**在Java程序中，这个作用域外的对象最终有两个去向。首先，可以通过复制或者传递，在作用域外部仍然可以访问这个对象**。其次，就是销毁对象。不过我们不用通过代码来销毁这个以前创建的对象。因为在Java语言中有一种叫做**垃圾回收器**的处理机制，其可以用来动态监视New关键字创建的所有对象，并根据一定的规则来判断哪些对象不会再被引用。如果其判断某个对象不再被引用话，则会自动释放这些对象所占用的内存空间，以供其他新的对象所使用。我们程序开发人员只管创建对象即可，而不用去担心什么时候去销毁对象。为此，这就可以消除C++语言面临的内存溢出问题。这个内存溢出问题就是因为程序开发人员用完对象后忘记销毁所造成的。

　　由于在Java程序开发中，我们开发人员不用关心对象的销毁问题，为此可以更多的精力放在代码的优化上。而不像C++语言那样，要把这个对象销毁问题当作头件大事来对待。虽然如此，不过Java程序员也不能够掉以轻心。特别是当我们在离开某个作用域后还需要访问这个对象的时候，一定要记得通过复制或者传递等手段把对象引用传递给其他作用域。否则的话，即使这个对象没有消亡，还实际存储在内存中，但是也会因为缺少了引用而无法访问他们。为此在跨作用域引用对象的时候，这个引用的复制与传递千万不能够忘了。

　　如果不幸忘了的话，那么在作用域外的代码就无法再访问这个对象。不过这个对象在一定时候会被垃圾回收器回收了。被释放了的内存空间就可以被重复使用，从而防止内存溢出的问题发生。

　　总之，当Java程序员在开发应用程序的时候，这个Java对象与Java变量作用域的差异，以及Java对象与其他语言对象作用域的差异，一定要了然于胸。这有助于Java程序员能够更好的利用这个Java对象。另外笔者不厌其烦的再强调一遍，默认情况下脱离了某个作用域之后，对象就失去了引用无法访问。如果要在作用域再访问这个对象的时候，则需要及时把这个引用复制或者传递出来。否则的话，作用域外的代码是无法再操作这个对象。

# C++作用域与可见域

## 一、作用域　　

　　c++作用域可分为5类：函数原型作用域、块作用域、类作用域、文件作用域和全局（程序）作用域（跨文件）。

1. 函数原型作用域（最小的作用域）

　　函数原型：int func(int x); 这是一个函数声明，函数形参x 的作用域就时所谓的函数原型作用域。

2. 块作用域

　　一对大括号 { ... } 内的一段程序，块中声明的标识符作用域就是块作用域。

3. 类作用域

　　类成员的作用域。

4. 文件作用域（static）

　　全局静态变量具有全局作用域，从声明处开始，到文件（.cpp文件）结尾处结束。

5. 全局（程序）作用域（extern）

　　全局变量具有全局作用域，只要在使用前对其进行声明（可定义性声明/引用性声明），便可在程序（有若干个文件组成）的任意位置使用全局变量。

## 二、可见域

　　作用域指的是变量理论上有效的源代码区域，而可见域指的是该变量实际的内存区域。如果没有屏蔽发生，可见域和作用域应该是等价的。

　　只有在可见域内才能对变量进行合法的访问。

　　引用声明不能提供全局可见性（不具备跨文件性质），这意味着，在使用全局变量之前，必须在当前文件或当前块中进行引用声明。

　　内部静态变量（局部static）的作用域、可见域及屏蔽法则和自动变量一样，但外部静态变量需要注意：在一个文件中声明的外部静态变量（全局static），将屏蔽其他文件中定义的同名全局变量。但是，不允许在同一个文件中定义同名的全局变量和外部静态变量。

　　默认情况下，函数是全局的，可以在不同的文件中共享。和全局变量一样，使用函数前必须要对其进行声明（包含有函数声明的头文件）。

　　可使用static关键字将函数声明为文件内部的，这样，只能在本文件中使用该函数，在函数定义和声明中都要使用static关键字。static函数将屏蔽其他文件中外部定义的同名函数。



# Python变量作用域

Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。

变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是：

- L （Local） 局部作用域
- E （Enclosing） 闭包函数外的函数中
- G （Global） 全局作用域
- B （Built-in） 内建作用域

以 L –> E –> G –>B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。

```python
x = int(2.9)  # 内建作用域
 
g_count = 0  # 全局作用域
def outer():
    o_count = 1  # 闭包函数外的函数中
    def inner():
        i_count = 2  # 局部作用域
```

**Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这这些语句内定义的变量，外部也可以访问**，如下代码：

```python
>>> if True:
...  msg = 'I am from Runoob'
... 
>>> msg
'I am from Runoob'
>>>
```

实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。

如果将 msg 定义在函数中，则它就是局部变量，外部不能访问：

```python
>>> def test():
...     msg_inner = 'I am from Runoob'
... 
>>> msg_inner
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'msg_inner' is not defined
>>>
```

从报错的信息上看，说明了 msg_inner 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。

------

 **在Python中，并不是任何代码块都能引入新的作用域，这与C有很大的不同：**

```C++
#include<stdio.h>
int main() {
    if(2 > 0) {
        int i = 0;
    }
    printf("i = %d", i);
    return 0;
}
```



​    在这段代码中，if子句引入了一个局部作用域，变量i就存在于这个局部作用域中，但对外不可见，因此，接下来在printf函数中对变量i的引用会引发编译错误。

​    但是，在Python中却并非如此：

```python
if True:
    i = 0
print i
```

​    在这段代码中，**if子句并没有引入一个局部作用域****，变量i仍然处在全局作用域中，因此，变量i对于接下来的print语句是可见的。**

​    实际上，在**Python**中，**只有模块，类以及函数**才会**引入新的作用域**，其它的代码块是不会引入新的作用域的。

​    在Python中，使用一个变量之前不必预先声明它，但是在真正使用它之前，它必须已经绑定到某个对象；而名字绑定将在当前作用域中引入新的变量，同时屏蔽外层作用域中的同名变量，不论这个名字绑定发生在当前作用域中的哪个位置。 

```python
def f():
    print i
f()
```

​    运行结果将显示：NameError: global name 'i' is not defined。Python首先在函数f的本地作用域中查找变量i，查找失败，接着在全局作用域和内置作用域中查找变量i，仍然失败，最终抛出NameError异常。

```python
i = 0
def f():
    i = 8
    print i
f()
print i
```

​    运行结果显示：8和0。i = 8是一个名字绑定操作，它在函数f的局部作用域中引入了新的变量i，屏蔽了全局变量i，因此f内部的print语句看到的是局部变量i，f外部的print语句看到的是全局变量i。

```python
i = 0
def f():
    print i
    i = 0
f()
```

​     运行结果显示：UnboundLocalError: local variable 'i' referenced before assignment。在这个例子当中，函数f中的变量i是局部变量，但是在print语句使用它的时候，它还未被绑定到任何对象之上，所以抛出异常。

```python
print i
i = 0
```

​    不论是以交互的方式运行，还是以脚本文件的方式运行，结果都显示：NameError: name 'i' is not defined。这里的输出结果又与上一个例子不同，这是因为它在顶级作用域（模块作用域）的缘故。对于模块代码而言，代码在执行之前，没有经过什么预处理，但是对于函数体而言，代码在运行之前已经经过了一个预处理，因此不论名字绑定发生在作用域的那个位置，它都能感知出来。Python虽然是一个静态作用域语言，但是名字查找确实动态发生的，因此直到运行的时候，才会发现名字方面的问题。
