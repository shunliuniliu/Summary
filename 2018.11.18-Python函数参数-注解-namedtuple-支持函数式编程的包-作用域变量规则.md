# 从定位参数到仅限关键字参数

```python
def test_arguments(name, *content, cls=None, **attrs):

    if name is not None:
        print("name: ", name)

    if content is not None:
        print("content: ", content)

    if cls is not None:
        print("cls: ", cls)

    if attrs is not None:
        print("attrs: ", attrs)



if __name__ == '__main__':

    my_list = [1,2,3]
    my_set = (1,2,3)
    #不要用数值作为key
    my_dict = {"a":"a","b":"b","c":12}

    test_arguments('Jinzhi')
    print()

    test_arguments('Jinzhi',"a",'b','c','d',cls="classmethod")
    print()
    #把my_list作为一个参数传入
    test_arguments('Jinzhi',my_list,cls="classmethod")
    print()
    #把my_list解析出多个参数传入
    test_arguments('Jinzhi',*my_list,cls="classmethod")
    print()
    #把my_set作为一个参数传入
    test_arguments('Jinzhi',my_set,cls="classmethod")
    print()
    #把my_set解析出多个参数传入
    test_arguments('Jinzhi',*my_set,cls="classmethod")
    print()
    #my_dict解析出key-value参数传入，不然报错
    test_arguments('Jinzhi',*my_set,cls="classmethod",**my_dict)
    print()
    
    special_dict = {"name":"a","b":"b","c":"c","cls":12}
    # special_dict解析出key-value参数传入，同名键绑定到对应的具名参数上，余下的则被**attrs捕获
    test_arguments(**special_dict)
    print()
```

# 函数注解——增加静态类型检查

实际上没有像Java那样去严格限制，依然是动态的。

Python对注解做的唯一的事情是，将它们存储在函数的`__annotations__`属性里。仅此而已，Python不做检查、不做限制、不做验证，什么操作都不做。

注解对Python解释器没有任何意义，注解只是元数据，可以提供IDE、框架和装饰器等工具使用。

比如：

- 未来Bobo等框架可以支持注解，并进一步自动处理请求。例如使用price:float注解的参数可以自动把查询字符串转换成函数期待的float类型。quantity:'int > 0'这样的字符串注解可以转换成对参数的验证。
- 函数注解的最大影响不一定是让Bobo等框架自动设置，而是为IDE和Lint程序等工具中的静态类型检查功能提供额外的类型信息。

```python

# 增加静态类型检查

my_string: str = "sad"
print(my_string)

from typing import Dict

fallback_home: Dict[str,str] = {
    "first_name": "UserFirstName",
    "last_name": "UserLastName",

}
print(fallback_home)


def get_first_name(full_name: str) -> str:

    return full_name.split(" ")[0]


raw_name: int = input("enter your name\n")

first_name: str = get_first_name(raw_name)

print(first_name)



from typing import Dict, List, Tuple

name_counts: Dict[str,int] = {
    "AA": 10,
    "BB": 20
}
print(name_counts)

numbers: List[int] = [1,2,3,4,5]
print(numbers)

list_of_dicts: List[Dict[str,int]] = [
    {"key1": 1},
    {"key2": 2}
]
print(list_of_dicts)

my_data: Tuple[str, int, float] = ("AA", 10, 5.9)
print(my_data)

```



# namedtuple

用法见下：

```python

def namedtuple(typename, field_names, *, verbose=False, rename=False, module=None):
    """Returns a new subclass of tuple with named fields.

    >>> Point = namedtuple('Point', ['x', 'y'])
    >>> Point.__doc__                   # docstring for the new class
    'Point(x, y)'
    >>> p = Point(11, y=22)             # instantiate with positional args or keywords
    >>> p[0] + p[1]                     # indexable like a plain tuple
    33
    >>> x, y = p                        # unpack like a regular tuple
    >>> x, y
    (11, 22)
    >>> p.x + p.y                       # fields also accessible by name
    33
    >>> d = p._asdict()                 # convert to a dictionary
    >>> d['x']
    11
    >>> Point(**d)                      # convert from a dictionary
    Point(x=11, y=22)
    >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields
    Point(x=100, y=22)

    """
省略源码
```

# 支持函数式编程的包

### operator模块

```python
itemgetter：从序列中取出元素。
常见用途：根据元素的某个字段给元组、列表排序
如果把多个参数传给itemgetter，它构建的函数会返回提取的值构成的元组。

attrgetter：读取对象属性
如果把多个属性名传给attrgetter，会返回提取的值构成的元组。

methodcall：
```

### functools.partial冻结参数

functools模块提供一系列的高阶函数

partial()及其变体partialmethod()

```python
用处很广
比如tag函数，可以利用partial将tag的定位参数、关键字参数给固定了。
```

lru_cache函数，会做备忘，是一种自动优化措施，会存储耗时的函数调用结果，避免重新计算。



# 作用域变量规则

```python
def test(a):
    print(a)
    print(b)
    
if __name__ == '__main__':
    b = 1
    test(3)
    
输出：
3
1

此时b作为全局变量
```



```python
def test(a):
    print(a)
    print(b)
    b = 2

if __name__ == '__main__':
    b = 1
    test(3)
    
报错：
UnboundLocalError: local variable 'b' referenced before assignment
    
此时b作为局部变量
```



```python
def test(a):
    print(a)
    print(b)
    

if __name__ == '__main__':
    b = 1
    test(3)
    print()
    b = 2
    test(3)

输出：
3
1

3
2
```



```python
def test(a):
    global b
    print(a)
    print(b)
    b = 2


if __name__ == '__main__':
    b = 1
    test(3)
    print()
    test(3)
    
输出：
3
1

3
2
```

