# Python3 关键字nonlocal和global的用法与区别

## 关键字nonlocal

在Python 2.x中，闭包只能读外部函数的变量，而不能改写它。为了解决这个问题，Python 3.x引入了nonlocal关键字，在闭包内用nonlocal声明变量，就可以让解释器在外层函数中查找变量名。

注意：关键字nonlocal:是python3.X中出现的,所以在python2.x中无法直接使用.

## 关键字global

Python里只有2种作用域：全局作用域和局部作用域。全局作用域是指当前代码所在模块的作用域，局部作用域是指当前函数或方法所在的作用域。局部作用域里的代码可以读外部作用域（包括全局作用域）里的变量，但不能更改它。如果想更改它，这里就要使用global关键字了

## 实例

关键字nonlocal的作用与关键字global类似，使用nonlocal关键字可以在一个嵌套的函数中修改嵌套作用域中的变量。但是global和nonlocal是用在不同的情况中。

看两个例子:

```python
name = 'pythontab'
def func()
    global name
    name = 'pythontab.com'
func()
print(name)

输出：
pythontab.com
```

name没有在func的入参中，所以没有global修饰，func中的局部变量name无法被识别为全局变量name，从而被修改。

```python
def func():
    name = 'pythontab'
    def foo():
        nonlocal name
        name = 'pythontab.com'
    foo()
    print(name)
func()


输出：
pythontab.com
```

name没有在foo的入参中，所以没有nonlocal修饰，func中的局部变量name无法被识别为上一级函数中的局部变量name，从而被修改。



## 总结

主要区别有以下两点：

1.两者的功能不同。

- global关键字修饰变量后标识该变量是全局变量，对该变量进行修改就是修改全局变量
- nonlocal关键字修饰变量后标识该变量是上一级函数中的局部变量，如果上一级函数中不存在该局部变量，nonlocal位置会发生错误（最上层的函数使用nonlocal修饰变量必定会报错）。

2.两者使用的范围不同。

- global关键字可以用在**任何地**方，包括最上层函数中和嵌套函数中，**即使之前未定义该变量**，global修饰后也可以直接使用
- **nonlocal关键字只能用于嵌套函数中**，**并且外层函数中定义了相应的局部变量**，否则会发生错误。



------

------



# Python:global,可变数据类型与不可变数据类型,在声明全局变量中的不同

当在函数内调用全局变量并对其重新赋值时，我们知道要用global在函数内部声明全局变量。

同时，也有种用法是说“当全局变量是string, int,tuple等不可变数据类型时，在函数重新定义赋值时要用global进行声明；当全局变量是list和dict等可变类型时，不用global声明也可以”。

这说法前半句是正确的，后半句不完全正确。看以下代码：

（指的是，对可变类型的全局变量，在函数中进行赋值操作，a=[1,2,3]）

```
a=[1,2,3]  
def test():  
    a=[4,5,6]  
    print(a)  
test()  
print(a) 
```

输出结果分别是[1,2,3]和[4,5,6]，跟我们想要的都是[1,2,3]不同。也就是说当全局变量是list或dict这种可变类型在函数内重新定义。

赋值时，也要加上global进行声明才能够修改变量的值，即  函数内有 list=  或dict= 这样的式子，也要用global声明list或dict类型的全局变量。

原因(综合网上搜索到的信息)：

因为python是弱类型语言，赋值语句和其定义变量的语句一样，所以a=[4,5,6]'这句中，它是“有歧义的“，因为它既可以是表示。

引用全局变量a，也可以是创建一个新的局部变量，所以在python中，默认它的行为是创建局部变量，除非显式声明global，global定义的本地变量会变成其对应全局变量的一个别名，即是同一个变量。

什么样的情况下，list和dict不用global呢？

当在函数内是用list或dict的内置函数进行修改时，如append、remove等方法，而非‘=’赋值时，可以不用global声明





## 补充结论（不可变类型和可变类型的全局变量）

### 不可变类型的全局变量

- 读取时，不需要global关键字
- 修改时，需要global关键字

因为map_size是不可变类型，所以**在函数内修改的话，会变成局部变量**，但是map_size又没有在函数内定义过，所以会报错。（类、实例也有类似情况，类变量被修改后会变成实例变量）

如果对不可变类型的全局变量进行修改，就是用global

### 可变类型的全局变量

- 读取和修改，都不需要global关键字
- 但是如果是赋值操作，a=[1,2,3]。
  - 不用global的话，就是新建了一个局部变量，生命周期就是函数的生命周期
  - 用global的话，就是表示对全局变量a，进行了重新赋值

###  全局变量

- **全局变量** 是在 **函数外部定义** 的变量，所有函数内部都可以使用这个变量

**这是一个读取不可变类型的全局变量的例子**

```
# 定义一个全局变量
num = 10


def demo1():

    print(num)


def demo2():

    print(num)

demo1()
demo2()

print("over")
```

**注意**：函数执行时，**需要处理变量时** 会：

1. **首先** 查找 **函数内部** 是否存在 **指定名称 的局部变量**，**如果有，直接使用**
2. 如果没有，查找 **函数外部** 是否存在 **指定名称 的全局变量**，**如果有，直接使用**
3. 如果还没有，程序报错！

#### 1) 函数不能直接修改 `全局变量的引用`

- **全局变量** 是在 **函数外部定义** 的变量（没有定义在某一个函数内），**所有函数** 内部 **都可以使用这个变量**

> 提示：在其他的开发语言中，大多 **不推荐使用全局变量** —— 可变范围太大，导致程序不好维护！

- 在函数内部，可以 **通过全局变量的引用获取对应的数据**
- 但是，**不允许直接修改全局变量的引用** —— 使用赋值语句修改全局变量的值

```
num = 10


def demo1():

    print("demo1" + "-" * 50)

    # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已
    num = 100
    print(num)


def demo2():

    print("demo2" + "-" * 50)
    print(num)

demo1()
demo2()

print("over")
```

> 注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值

#### 2) 在函数内部修改全局变量的值

- 如果在函数中需要修改全局变量，需要使用 `global` 进行声明

```
num = 10


def demo1():

    print("demo1" + "-" * 50)

    # global 关键字，告诉 Python 解释器 num 是一个全局变量
    global num
    # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已
    num = 100
    print(num)


def demo2():

    print("demo2" + "-" * 50)
    print(num)

demo1()
demo2()

print("over")
```

#### 3) 全局变量定义的位置

- 为了保证所有的函数都能够正确使用到全局变量，应该 **将全局变量定义在其他函数的上方**

```
a = 10


def demo():
    print("%d" % a)
    print("%d" % b)
    print("%d" % c)

b = 20
demo()
c = 30
```

**注意**

- 由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！



#### 4) 全局变量命名的建议

- 为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如：
- 全局变量名前应该增加 `g_` 或者 `gl_` 的前缀























